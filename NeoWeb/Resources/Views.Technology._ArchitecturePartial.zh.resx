<?xml version="1.0" encoding="utf-8"?>
<root>
  <!-- 
    Microsoft ResX Schema 
    
    Version 2.0
    
    The primary goals of this format is to allow a simple XML format 
    that is mostly human readable. The generation and parsing of the 
    various data types are done through the TypeConverter classes 
    associated with the data types.
    
    Example:
    
    ... ado.net/XML headers & schema ...
    <resheader name="resmimetype">text/microsoft-resx</resheader>
    <resheader name="version">2.0</resheader>
    <resheader name="reader">System.Resources.ResXResourceReader, System.Windows.Forms, ...</resheader>
    <resheader name="writer">System.Resources.ResXResourceWriter, System.Windows.Forms, ...</resheader>
    <data name="Name1"><value>this is my long string</value><comment>this is a comment</comment></data>
    <data name="Color1" type="System.Drawing.Color, System.Drawing">Blue</data>
    <data name="Bitmap1" mimetype="application/x-microsoft.net.object.binary.base64">
        <value>[base64 mime encoded serialized .NET Framework object]</value>
    </data>
    <data name="Icon1" type="System.Drawing.Icon, System.Drawing" mimetype="application/x-microsoft.net.object.bytearray.base64">
        <value>[base64 mime encoded string representing a byte array form of the .NET Framework object]</value>
        <comment>This is a comment</comment>
    </data>
                
    There are any number of "resheader" rows that contain simple 
    name/value pairs.
    
    Each data row contains a name, and value. The row also contains a 
    type or mimetype. Type corresponds to a .NET class that support 
    text/value conversion through the TypeConverter architecture. 
    Classes that don't support this are serialized and stored with the 
    mimetype set.
    
    The mimetype is used for serialized objects, and tells the 
    ResXResourceReader how to depersist the object. This is currently not 
    extensible. For a given mimetype the value must be set accordingly:
    
    Note - application/x-microsoft.net.object.binary.base64 is the format 
    that the ResXResourceWriter will generate, however the reader can 
    read any of the formats listed below.
    
    mimetype: application/x-microsoft.net.object.binary.base64
    value   : The object must be serialized with 
            : System.Runtime.Serialization.Formatters.Binary.BinaryFormatter
            : and then encoded with base64 encoding.
    
    mimetype: application/x-microsoft.net.object.soap.base64
    value   : The object must be serialized with 
            : System.Runtime.Serialization.Formatters.Soap.SoapFormatter
            : and then encoded with base64 encoding.

    mimetype: application/x-microsoft.net.object.bytearray.base64
    value   : The object must be serialized into a byte array 
            : using a System.ComponentModel.TypeConverter
            : and then encoded with base64 encoding.
    -->
  <xsd:schema id="root" xmlns="" xmlns:xsd="http://www.w3.org/2001/XMLSchema" xmlns:msdata="urn:schemas-microsoft-com:xml-msdata">
    <xsd:import namespace="http://www.w3.org/XML/1998/namespace" />
    <xsd:element name="root" msdata:IsDataSet="true">
      <xsd:complexType>
        <xsd:choice maxOccurs="unbounded">
          <xsd:element name="metadata">
            <xsd:complexType>
              <xsd:sequence>
                <xsd:element name="value" type="xsd:string" minOccurs="0" />
              </xsd:sequence>
              <xsd:attribute name="name" use="required" type="xsd:string" />
              <xsd:attribute name="type" type="xsd:string" />
              <xsd:attribute name="mimetype" type="xsd:string" />
              <xsd:attribute ref="xml:space" />
            </xsd:complexType>
          </xsd:element>
          <xsd:element name="assembly">
            <xsd:complexType>
              <xsd:attribute name="alias" type="xsd:string" />
              <xsd:attribute name="name" type="xsd:string" />
            </xsd:complexType>
          </xsd:element>
          <xsd:element name="data">
            <xsd:complexType>
              <xsd:sequence>
                <xsd:element name="value" type="xsd:string" minOccurs="0" msdata:Ordinal="1" />
                <xsd:element name="comment" type="xsd:string" minOccurs="0" msdata:Ordinal="2" />
              </xsd:sequence>
              <xsd:attribute name="name" type="xsd:string" use="required" msdata:Ordinal="1" />
              <xsd:attribute name="type" type="xsd:string" msdata:Ordinal="3" />
              <xsd:attribute name="mimetype" type="xsd:string" msdata:Ordinal="4" />
              <xsd:attribute ref="xml:space" />
            </xsd:complexType>
          </xsd:element>
          <xsd:element name="resheader">
            <xsd:complexType>
              <xsd:sequence>
                <xsd:element name="value" type="xsd:string" minOccurs="0" msdata:Ordinal="1" />
              </xsd:sequence>
              <xsd:attribute name="name" type="xsd:string" use="required" />
            </xsd:complexType>
          </xsd:element>
        </xsd:choice>
      </xsd:complexType>
    </xsd:element>
  </xsd:schema>
  <resheader name="resmimetype">
    <value>text/microsoft-resx</value>
  </resheader>
  <resheader name="version">
    <value>2.0</value>
  </resheader>
  <resheader name="reader">
    <value>System.Resources.ResXResourceReader, System.Windows.Forms, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089</value>
  </resheader>
  <resheader name="writer">
    <value>System.Resources.ResXResourceWriter, System.Windows.Forms, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089</value>
  </resheader>
    <data name="Developer Experience">
        <value>开发者体验</value>
    </data>

    <data name="Supporting multiple languages is only one small part of what Neo offers to developers. It caters to varying end user needs with both traditional and web-based IDE integrations. One-stop shop smart contract and dApp development frameworks are also provided to quickly bootstrap developers and get them up and running as architects for the next-generation Internet.">
        <value>对多种编程语言的支持仅仅是 Neo 开发者友好度的部分体现。通过传统的与基于 Web 的 IDE 集成，Neo 可以满足不断变化的用户需求。除此之外，Neo 还提供一站式智能合约和 dApp 开发框架，帮助开发人员快速入门并成长为下一代互联网的架构师。</value>
    </data>

    <data name="Thanks to the contributions of Neo's independent developer community, users can begin creating applications for the Neo blockchain without ever needing to install any software. Tools such as NEO-ONE, NeoCompiler Eco, and Neo Playground, built by teams from the US, Brazil, and Switzerland respectively, are all accessible directly from within a browser.">
        <value>得益于 Neo 遍布全球的地理社区开发团队，开发者无需安装任何软件便可开始开发应用。包括由 Neo 美国，巴西和瑞士的开发者社区构建的 NEO-ONE，NeoCompiler Eco 和 Neo Playground 等工具都可以在浏览器中直接访问。</value>
    </data>

    <data name="From MVP to production-ready">
        <value>完善的合约调试</value>
    </data>

    <data name="Sometimes errors happen, even in a carefully tested application, and in a decentralized environment they can be very difficult to replicate. Thanks to execution trace capture, you can grab and investigate any transaction on a Neo network and replay it through the Neo Debugger.">
        <value>即使经过仔细的测试，应用中的错误有时也难以避免。在分布式的环境下，这些错误也会更加难以重现。借助 Neo 调试器提供的追踪捕获功能，开发者可以捕获和调查 Neo 网络上的任何事务，然后通过 Neo 调试器让它重现。</value>
    </data>

    <data name="The debugger provides a disassembled bytecode view, source code mapping, and revolutionary time-travel debugging tools. Armed with these powerful resources, you can skip the tedious hours spent tracking down bugs by directly stepping forward or backward through both the source code and bytecode, inspecting carefully for any unexpected state changes.">
        <value>Neo 调试器提供了反汇编的字节码视图，源代码映射和革命性的时间旅行调试工具。有了这些强大的工具，开发者可以直接在源代码和字节码之间前进或后退，并捕捉任何意外的状态更改，从极大程度上减少了乏味枯燥的测试流程。</value>
    </data>
</root>
